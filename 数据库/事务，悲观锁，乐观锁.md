# 事务，悲观锁，乐观锁
http://chenzhou123520.iteye.com/blog/1860954
http://chenzhou123520.iteye.com/blog/18x63407
事务参考 http://www.cnblogs.com/DreamDrive/p/4090919.html

##1.  事务四大特性:

 *  原子性(Atomicity)  :强调的事务的不可分割.
 *  一致性(Consistency)    :强调的事务的执行前后,数据库的的完整性保持一致.
 *  隔离性(Isolation)  :强调的事务的并发的访问,一个事务的执行,不应该受到另一个事务的打扰.
* 持久性(Durability) :强调的事务结束之后,数据就永久的保存的数据库中.

##2.如果不考虑事务的隔离性:引发一些安全性问题.

*  脏读  :一个事务,读到了另一个事务未提交数据.
*  不可重复读 :一个事务,读到了另一个事务的提交数据（update）.导致查询结果不一致.
*  虚读(幻读) :一个事务,读到了另一个事务的提交数据(insert).导致查询结果不一致

##3.数据库中事务的隔离级别:

*  read uncommitted(未提交读) :脏读、不可重复读、虚读都是有可能发生的.
* read committed(已提交读)   :避免脏读,但是不可重复读和虚读是有可能发生
*  repeatable read(重复读)    :避免脏读、不可重复读.但是虚读是有可能发生
*  serializable(串行的)       :避免脏读、不可重复读、虚读的发生.

##4.安全性与效率
 数据库会比对安全性和效率问题:一般不会采用read uncommitted 和 serializable
 
 *   MYSQL数据库默认的隔离级别:repeatable read
*   Oracle数据库默认的隔离级别:read committed

另外oracle中可以把隔离级别设置成自身固有的readonly隔离级别.（这种隔离级别可以查,不可以改.）
面试问oracle有几个隔离级别,答案有三个!
自身支持的两个和一个固有的readonly.
Oracle支持的2种事务隔离级别ReadCommited，Serializable+readOnly
Mysql支持4种事务隔离级别

#悲观锁

##悲观锁介绍（百科）：
悲观锁，正如其名，它指的是对数据被外界修改持保守态度（包括本系统当前的其他事务，以及来自外部系统的事务处理）因此，在整个数据处理过程中，将数据处于锁定状态。悲观锁的实现，往往依靠数据库提供的锁机制（也只有数据库层提供的锁机制才能真正保证数据访问的排他性，否则，即使在本系统中实现了加锁机制，也无法保证外部系统不会修改数据）。

注：要使用悲观锁，我们必须关闭mysql数据库的自动提交属性，因为MySQL默认使用autocommit模式，也就是说，当你执行一个更新操作后，MySQL会立刻将结果进行提交。
我们使用了select…for update的方式，这样就通过数据库实现了悲观锁。

注：需要注意的是，在事务中，只有SELECT ... FOR UPDATE 或LOCK IN SHARE MODE 同一笔数据时会等待其它事务结束后才执行，一般SELECT ... 则不受此影响。拿上面的实例来说，当我执行select status from t_goods where id=1 for update;后。我在另外的事务中如果再次执行select status from t_goods where id=1 for update;则第二个事务会一直等待第一个事务的提交，此时第二个查询处于阻塞的状态，但是如果我是在第二个事务中执行select status from t_goods where id=1;则能正常查询出数据，不会受第一个事务的影响。
 
补充：MySQL select…for update的Row Lock与Table Lock
上面我们提到，使用select…for update会把数据给锁住，不过我们需要注意一些锁的级别，MySQL InnoDB默认Row-Level Lock，所以只有「明确」地指定主键，MySQL 才会执行Row lock (只锁住被选取的数据) ，否则MySQL 将会执行Table Lock (将整个数据表单给锁住)。
##悲观锁的缺点
悲观锁并不是适用于任何场景，它也有它存在的一些不足，因为悲观锁大多数情况下依靠数据库的锁机制实现，以保证操作最大程度的独占性。如果加锁的时间过长，其他用户长时间无法访问，影响了程序的并发访问性，同时这样对数据库性能开销影响也很大，特别是对长事务而言，这样的开销往往无法承受。所以与悲观锁相对的，我们有了乐观锁

#乐观锁介绍：
乐观锁（ Optimistic Locking ） 相对悲观锁而言，乐观锁假设认为数据一般情况下不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果发现冲突了，则让返回用户错误的信息，让用户决定如何去做。那么我们如何实现乐观锁呢，一般来说有以下2种方式：
###1.使用版本号（Version）记录机制实现。
当读取数据时，将version字段的值一同读出，数据每更新一次，对此version值加一。当我们提交更新的时候，判断数据库表对应记录的当前版本信息与第一次取出来的version值进行比对，如果数据库表当前版本号与第一次取出来的version值相等，则予以更新，否则认为是过期数据。用下面的一张图来说明：
###2.使用时间戳
同样是在需要乐观锁控制的table中增加一个字段，名称无所谓，字段类型使用时间戳（timestamp）, 和上面的version类似，也是在更新提交的时候检查当前数据库中数据的时间戳和自己更新前取到的时间戳进行对比，如果一致则OK，否则就是版本冲突。


