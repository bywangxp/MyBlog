# 静态绑定与动态绑定(多态)
参考博客：http://hxraid.iteye.com/blog/428891
解析过程：虚拟机将常量池内的符号引用替换为直接引用的过程

1. 符号引用：以一组符号来描述所引用的目标，只要使用时能无歧义定位所引用的位置，引用的目标不一定已经加载到内存中。不同虚拟机实现的内存布局各不相同，但是他们接受的符号引用必须一致，因此符号引用的字面量明确定义在java虚拟机的Class文件格式中
2. 直接引用：直接指向目标的指针。相对偏移量或者一个能间接定位到目标的句柄。如果有了直接引用，那引用的目标必定已经在内存中了。

<font color='red'>重要</font>：由于虚拟机并未规定解析阶段发生的具体时间，只要在执行getstatic，getfield，invokeddynamic，invokestatic，putstatic，invokevirtual。。。等用于操作符号引用的字节码指令之前，先对它们所使用的符号引用进行解析。因此虚拟机根据需要判断到底是在类被加载器加载的时候对常量池中的符号引用进行解析，还是等到一个符号引用被使用前才解析它。

##静态绑定机制：
>案列：代码中调用到静态方法则会被编译器编译成一条指令invokestatic #13表示当前类的常量池中第13个常量表的索引项

常量池解析:在方法区中找到静态绑定的方法的直接地址，并将这个地址记录到当前类的常量池索引为13的常量表中。

经过常量池解析之后，JVM就能够确定要调用的f1()方法具体在内存的什么位置上了。实际上，这个信息在编译阶段就已经在StaticCall类的常量池中记录了下来。这种在编译阶段就能够确定调用哪个方法的方式，我们叫做 静态绑定机制 。
>除了被static 修饰的静态方法，所有被private 修饰的私有方法、被final 修饰的禁止子类覆盖的方法都会被编译成invokestatic指令。另外所有类的初始化方法<init>和<clinit>会被编译成invokespecial指令。JVM会采用静态绑定机制来顺利的调用这些方法。


##动态绑定机制：
方法表：在JVM加载类的同时，会在方法区中为这个类存放很多信息，其中就有一个数据结构叫方法表。它以数组的形式记录了当前类及其所有超类的可见方法字节码在内存中的直接地址 。下图是上面源代码中Father和Sun类在方法区中的方法表



![屏幕快照 2017-04-13 22.48.09](media/14920929644294/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-04-13%2022.48.09.png)

图中的方法表有两个特点：(1) 子类方法表中继承了父类的方法，比如Father extends Object。 (2) 相同的方法(相同的方法签名：方法名和参数列表)在所有类的方法表中的索引相同。比如Father方法表中的f1()和Son方法表中的f1()都位于各自方法表的第11项中。

```
//Farther为son的父类
Father father=new Son(); //多态  
father.f1(); //打印结果： Son-f1() 


多态调用的字节码指令代码

  new hr.test.Son [13] //在堆中开辟一个Son对象的内存空间，并将对象引用压入操作数栈  
  dup    
  invokespecial #7 [15] // 调用初始化方法来初始化堆中的Son对象   
  astore_1 //弹出操作数栈的Son对象引用压入局部变量1中  
  aload_1 //取出局部变量1中的对象引用压入操作数栈  
  invokevirtual #15 //调用f1()方法  
  return 
```

其中invokevirtual指令的详细调用过程是这样的：
       (1) invokevirtual指令中的#15指的是当前类的常量池中第15个常量表的索引项。这个常量表(CONSTATN_Methodref_info ) 记录的是方法f1信息的符号引用(包括f1所在的类名，方法名和返回类型)。JVM会首先根据这个符号引用找到调用方法f1的类的全限定名: hr.test.Father。这是因为调用方法f1的类的对象father声明为Father类型。
       (2) 在Father类型的方法表中查找方法f1，如果找到，则将方法f1在方法表中的索引项11(如上图)记录到当前类的常量池中第15个常量表中(常量池解析 )。这里有一点要注意：如果Father类型方法表中没有方法f1，那么即使Son类型中方法表有，编译的时候也通过不了。因为调用方法f1的类的对象father的声明为Father类型。
     
       
 (3) 在调用invokevirtual指令前有一个aload_1指令，它会将开始创建在堆中的Son对象的引用压入操作数栈。然后invokevirtual指令会根据这个Son对象的引用首先找到堆中的Son对象，然后进一步找到Son对象所属类型的方法表。过程如下图所示：
               ![屏幕快照 2017-04-13 23.02.36](media/14920929644294/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-04-13%2023.02.36.png)
     
    
(4) 这是通过第(2)步中解析完成的#15常量表中的方法表的索引项11，可以定位到Son类型方法表中的方法f1()，然后通过直接地址找到该方法字节码所在的内存空间。
很明显，根据对象(father)的声明类型(Father)还不能够确定调用方法f1的位置，必须根据father在堆中实际创建的对象类型Son来确定f1方法所在的位置。这种在程序运行过程中，通过动态创建的对象的方法表来定位方法的方式，我们叫做 动态绑定机制 。
>1.首先会找到被调用方法所属类的全限定名
2.在此类的方法表中寻找被调用方法，如果找到，会将方法表中此方法的索引项记录到常量池中（这个过程叫常量池解析），如果没有，编译失败。
3.根据具体实例化的对象找到方法区中此对象的方法表，再找到方法表中的被调用方法，最后通过直接地址找到字节码所在的内存空间。

#总结重点
>(1) 所有私有方法、静态方法、构造器及初始化方法<clinit>都是采用静态绑定机制。在编译器阶段就已经指明了调用方法在常量池中的符号引用，JVM运行的时候只需要进行一次常量池解析即可。
(2) 类对象方法的调用必须在运行过程中采用动态绑定机制。
 首先，根据对象的声明类型(对象引用的类型)找到“合适”的方法。具体步骤如下：
① 如果能在声明类型中匹配到方法签名完全一样(参数类型一致)的方法，那么这个方法是最合适的。
② 在第①条不能满足的情况下，寻找可以“凑合”的方法。标准就是通过将参数类型进行自动转型之后再进行匹配。如果匹配到多个自动转型后的方法签名f(A)和f(B)，则用下面的标准来确定合适的方法：传递给f(A)方法的参数都可以传递给f(B)，则f(A)最合适。反之f(B)最合适 。
  ③ 如果仍然在声明类型中找不到“合适”的方法，则编译阶段就无法通过。
 然后，根据在堆中创建对象的实际类型找到对应的方法表，从中确定具体的方法在内存中的位置。

